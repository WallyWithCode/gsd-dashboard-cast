---
phase: 03-video-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified: [src/video/stream.py, tests/test_video_pipeline.py, tests/__init__.py]
autonomous: true

# Goal-backward verification
must_haves:
  truths:
    - "Stream manager can start complete pipeline (Xvfb → Browser → FFmpeg → Cast)"
    - "Stream automatically stops after configured duration"
    - "End-to-end latency is under 5 seconds (measured by test)"
    - "Quality presets work correctly (1080p, 720p, low-latency)"
  artifacts:
    - path: "src/video/stream.py"
      provides: "Complete streaming orchestration with duration support"
      min_lines: 100
      exports: ["StreamManager"]
    - path: "tests/test_video_pipeline.py"
      provides: "Integration tests for video pipeline"
      min_lines: 80
  key_links:
    - from: "StreamManager"
      to: "XvfbManager + BrowserManager + FFmpegEncoder + CastSessionManager"
      via: "orchestrates all components in sequence"
      pattern: "async with.*Manager"
    - from: "StreamManager.start_stream()"
      to: "asyncio.wait_for()"
      via: "enforces duration timeout"
      pattern: "wait_for.*timeout=duration"
    - from: "FFmpeg output"
      to: "Cast session"
      via: "stream URL passed to Cast"
      pattern: "cast.*load.*stream_url"
---

<objective>
Implement complete streaming orchestration with duration control and comprehensive testing.

Purpose: Integrate all video pipeline components (Xvfb, Browser, FFmpeg, Cast) into a unified streaming workflow with automatic timeout/duration handling. Verify end-to-end latency and quality presets through integration tests.

Output: StreamManager orchestrator with duration support and comprehensive test coverage proving the pipeline works end-to-end.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Dependencies from this phase
@.planning/phases/03-video-pipeline/03-01-SUMMARY.md — FFmpegEncoder and quality config
@.planning/phases/03-video-pipeline/03-02-SUMMARY.md — XvfbManager

# Dependencies from prior phases
@.planning/phases/01-browser-foundation/01-01-SUMMARY.md — BrowserManager with auth
@.planning/phases/02-cast-integration/02-01-SUMMARY.md — CastSessionManager with HDMI-CEC

# Research context
@.planning/research/ARCHITECTURE.md — Pipeline architecture pattern
@.planning/research/PITFALLS.md — FFmpeg performance considerations

# Source files to integrate
@src/browser/manager.py
@src/browser/auth.py
@src/cast/session.py
@src/cast/discovery.py
@src/video/quality.py
@src/video/encoder.py
@src/video/capture.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create streaming orchestrator with duration control</name>
  <files>src/video/stream.py</files>
  <action>
Create src/video/stream.py with StreamManager class that orchestrates the complete pipeline.

Class structure:

class StreamManager:
    """Orchestrates complete streaming pipeline from browser to Cast.

    Manages the lifecycle of all components:
    1. Xvfb virtual display
    2. Browser with authentication
    3. FFmpeg video encoding
    4. Cast session to Android TV

    Supports automatic timeout/duration to stop streaming after configured time.

    Usage:
        manager = StreamManager(
            url="https://dashboard.local",
            cast_device_name="Living Room TV",
            quality_preset="1080p",
            duration=60  # Stop after 60 seconds
        )
        await manager.start_stream()
    """

Methods:

1. __init__(
       self,
       url: str,
       cast_device_name: str,
       quality_preset: str = "720p",
       duration: Optional[int] = None,
       auth_config: Optional[dict] = None
   ):
   - Store all parameters
   - Validate URL (must be HTTPS for Cast - from REQUIREMENTS.md BROWSER-03, but deferred to Phase 5)
   - Validate quality_preset exists in QUALITY_PRESETS
   - Log configuration

2. async start_stream(self) -> dict:
   - Main orchestration method
   - Return dict with status, stream_url, device info

   Implementation:

   ```python
   # Import all required managers
   from .capture import XvfbManager
   from .encoder import FFmpegEncoder
   from .quality import get_quality_config
   from ..browser.manager import BrowserManager
   from ..browser.auth import inject_auth
   from ..cast.discovery import get_cast_device
   from ..cast.session import CastSessionManager

   try:
       # Get quality configuration
       quality = get_quality_config(self.quality_preset)

       # Discover Cast device
       cast_device = await get_cast_device(self.cast_device_name)
       if not cast_device:
           raise ValueError(f"Cast device not found: {self.cast_device_name}")

       # Start Xvfb virtual display
       async with XvfbManager(resolution=quality.resolution) as display:

           # Launch browser with auth
           async with BrowserManager() as browser:
               page = await browser.get_page(self.url)

               # Inject authentication if provided
               if self.auth_config:
                   await inject_auth(page, self.auth_config)

               # Wait for page to load
               await page.wait_for_load_state('networkidle', timeout=10000)

               # Start FFmpeg encoding
               async with FFmpegEncoder(quality, display=display) as stream_url:

                   # Start Cast session
                   async with CastSessionManager(cast_device) as cast_session:

                       # Load stream URL in Cast device
                       # Note: In Phase 4, this will use actual HTTP server URL
                       # For now, store URL for future use
                       logger.info(f"Stream URL ready: {stream_url}")
                       logger.info(f"Cast session active: {cast_device.device.friendly_name}")

                       # If duration specified, wait for timeout
                       if self.duration:
                           logger.info(f"Streaming for {self.duration} seconds...")
                           await asyncio.sleep(self.duration)
                           logger.info("Duration reached, stopping stream")
                       else:
                           # Stream indefinitely (until external stop signal)
                           logger.info("Streaming indefinitely (no duration set)")
                           await asyncio.sleep(float('inf'))  # Placeholder for Phase 4 webhook stop

       return {
           "status": "completed",
           "stream_url": stream_url,
           "device": cast_device.device.friendly_name,
           "duration": self.duration
       }

   except Exception as e:
       logger.error(f"Streaming failed: {e}")
       raise
   ```

3. async stop_stream(self):
   - Placeholder for Phase 4 webhook-triggered stop
   - For now, duration timeout handles auto-stop
   - Log that explicit stop was called
   - In Phase 4, this will use asyncio.Event to signal stop

Error handling:
- Catch and log all exceptions with context
- Ensure all resources cleaned up via context managers
- Raise exceptions after cleanup for caller to handle
- Provide detailed error messages for debugging

Add comprehensive logging at INFO level for pipeline stages.
  </action>
  <verify>python -c "import asyncio; from src.video.stream import StreamManager; print('StreamManager imports successfully')"</verify>
  <done>StreamManager class exists with start_stream method that orchestrates Xvfb → Browser → FFmpeg → Cast, duration timeout enforced with asyncio.sleep, all components use context managers</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive integration tests</name>
  <files>tests/test_video_pipeline.py</files>
  <action>
Create tests/test_video_pipeline.py with integration tests for the video pipeline.

Test structure (use pytest with pytest-asyncio):

```python
"""Integration tests for video streaming pipeline.

Tests complete pipeline from browser to video encoding, verifying:
- Quality presets work correctly
- Duration control functions properly
- Component integration succeeds
- End-to-end latency is acceptable
"""

import pytest
import asyncio
import os
from unittest.mock import Mock, patch, AsyncMock
from src.video.stream import StreamManager
from src.video.quality import get_quality_config, QUALITY_PRESETS
from src.video.encoder import FFmpegEncoder
from src.video.capture import XvfbManager


class TestQualityConfiguration:
    """Test quality preset configuration."""

    def test_quality_presets_exist(self):
        """Verify all required quality presets exist."""
        assert '1080p' in QUALITY_PRESETS
        assert '720p' in QUALITY_PRESETS
        assert 'low-latency' in QUALITY_PRESETS

    def test_1080p_preset_configuration(self):
        """Verify 1080p preset has correct parameters."""
        config = get_quality_config('1080p')
        assert config.resolution == (1920, 1080)
        assert config.bitrate == 5000
        assert config.latency_mode == 'normal'

    def test_720p_preset_configuration(self):
        """Verify 720p preset has correct parameters."""
        config = get_quality_config('720p')
        assert config.resolution == (1280, 720)
        assert config.bitrate == 2500

    def test_low_latency_preset_configuration(self):
        """Verify low-latency preset has correct parameters."""
        config = get_quality_config('low-latency')
        assert config.preset == 'ultrafast'
        assert config.latency_mode == 'low'

    def test_invalid_preset_raises_error(self):
        """Verify unknown preset name raises ValueError."""
        with pytest.raises(ValueError):
            get_quality_config('invalid-preset')


class TestFFmpegEncoder:
    """Test FFmpeg encoder functionality."""

    def test_ffmpeg_args_include_quality_params(self):
        """Verify FFmpeg args include resolution and bitrate from config."""
        config = get_quality_config('1080p')
        encoder = FFmpegEncoder(config)
        args = encoder.build_ffmpeg_args('/tmp/test.m3u8')

        # Check key parameters present
        assert '-video_size' in args
        assert '1920x1080' in args
        assert '-b:v' in args
        assert '5000k' in args

    def test_low_latency_mode_args(self):
        """Verify low-latency mode includes zerolatency tuning."""
        config = get_quality_config('low-latency')
        encoder = FFmpegEncoder(config)
        args = encoder.build_ffmpeg_args('/tmp/test.m3u8')

        # Low-latency specific flags
        assert '-tune' in args
        assert 'zerolatency' in args
        assert '-bf' in args
        assert '0' in args  # No B-frames

    def test_normal_latency_mode_args(self):
        """Verify normal mode allows B-frames for better compression."""
        config = get_quality_config('1080p')
        encoder = FFmpegEncoder(config)
        args = encoder.build_ffmpeg_args('/tmp/test.m3u8')

        # Normal latency allows B-frames
        assert '-bf' in args
        idx = args.index('-bf')
        assert args[idx + 1] == '2'  # 2 B-frames


@pytest.mark.asyncio
class TestStreamingOrchestration:
    """Test complete streaming pipeline orchestration."""

    @patch('src.video.stream.get_cast_device')
    @patch('src.video.capture.asyncio.create_subprocess_exec')
    async def test_stream_manager_initialization(self, mock_subprocess, mock_cast):
        """Verify StreamManager initializes with correct parameters."""
        manager = StreamManager(
            url="https://dashboard.local",
            cast_device_name="Test TV",
            quality_preset="720p",
            duration=30
        )

        assert manager.url == "https://dashboard.local"
        assert manager.cast_device_name == "Test TV"
        assert manager.quality_preset == "720p"
        assert manager.duration == 30

    async def test_duration_control(self):
        """Verify stream stops after configured duration."""
        # Mock all components to test duration logic only
        with patch.multiple(
            'src.video.stream',
            XvfbManager=AsyncMock(),
            BrowserManager=AsyncMock(),
            FFmpegEncoder=AsyncMock(),
            CastSessionManager=AsyncMock(),
            get_cast_device=AsyncMock(return_value=Mock())
        ):
            manager = StreamManager(
                url="https://test.local",
                cast_device_name="Test TV",
                quality_preset="720p",
                duration=2  # 2 second test
            )

            import time
            start = time.time()
            await manager.start_stream()
            elapsed = time.time() - start

            # Should complete around 2 seconds (allow 1s tolerance)
            assert 1.5 < elapsed < 3.5


@pytest.mark.asyncio
class TestXvfbManager:
    """Test Xvfb display management."""

    @patch('src.video.capture.asyncio.create_subprocess_exec')
    async def test_xvfb_sets_display_env_var(self, mock_subprocess):
        """Verify DISPLAY environment variable is set."""
        mock_process = AsyncMock()
        mock_process.poll.return_value = None
        mock_subprocess.return_value = mock_process

        async with XvfbManager(display=':99') as display:
            assert os.environ.get('DISPLAY') == ':99'
            assert display == ':99'

        # Verify cleaned up after exit
        assert 'DISPLAY' not in os.environ or os.environ['DISPLAY'] != ':99'
```

Run tests to verify they execute without errors (mocks prevent actual Xvfb/FFmpeg execution).

Requirements: pytest, pytest-asyncio already in requirements.txt from Phase 1.
  </action>
  <verify>pytest tests/test_video_pipeline.py -v</verify>
  <done>Integration test suite exists with tests for quality config, FFmpeg args, stream orchestration, duration control, and Xvfb management. All tests pass.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] StreamManager orchestrates all components in correct order
- [ ] Duration timeout works (stream stops after configured time)
- [ ] Quality presets passed through to FFmpeg correctly
- [ ] Integration tests cover key functionality
- [ ] All tests pass without errors
- [ ] Context manager cleanup verified
</verification>

<success_criteria>

- All tasks completed without errors
- StreamManager exists with complete pipeline orchestration
- Duration control implemented with asyncio timeout
- Integration tests exist and pass
- Quality presets (1080p, 720p, low-latency) verified by tests
- End-to-end pipeline verified by integration tests
- All components use established context manager pattern
  </success_criteria>

<output>
After completion, create `.planning/phases/03-video-pipeline/03-03-SUMMARY.md`
</output>
