---
phase: 03-video-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/video/__init__.py, src/video/quality.py, src/video/encoder.py, requirements.txt]
autonomous: true

# Goal-backward verification
must_haves:
  truths:
    - "Quality presets (1080p, 720p, low-latency) exist with different resolution/bitrate configs"
    - "FFmpeg encoder can be configured with quality preset"
    - "FFmpeg process launches with correct encoding parameters"
  artifacts:
    - path: "src/video/quality.py"
      provides: "Quality preset definitions and configuration dataclass"
      min_lines: 40
      exports: ["QualityConfig", "QUALITY_PRESETS"]
    - path: "src/video/encoder.py"
      provides: "FFmpeg encoder with subprocess management"
      min_lines: 80
      exports: ["FFmpegEncoder"]
  key_links:
    - from: "encoder.py"
      to: "quality.py"
      via: "imports QualityConfig"
      pattern: "from .quality import QualityConfig"
    - from: "FFmpegEncoder.build_args()"
      to: "config.resolution"
      via: "constructs FFmpeg args from quality config"
      pattern: "config\\.resolution|config\\.bitrate|config\\.preset"
---

<objective>
Implement video encoding foundation with FFmpeg integration and quality configuration.

Purpose: Establish the core video encoding pipeline with configurable quality presets that will be used by the streaming orchestrator. This is the foundation for rendering web pages to Cast-compatible video streams.

Output: FFmpeg encoder module with quality configuration system supporting 1080p, 720p, and low-latency presets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md

# Prior phase context
@.planning/phases/01-browser-foundation/01-01-SUMMARY.md — async patterns, context manager pattern established
@.planning/phases/02-cast-integration/02-01-SUMMARY.md — Cast session management, run_in_executor for blocking calls

# Research findings inform this plan:
- Use Xvfb + x11grab for video capture (simpler than CDP screencast)
- Low-latency encoding flags: -tune zerolatency, -bf 0, -refs 1
- Software encoding (libx264) for v1 - hardware acceleration for v2
- Quality presets defined in research: 1080p (5000k), 720p (2500k), low-latency (2000k)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quality configuration module</name>
  <files>src/video/__init__.py, src/video/quality.py</files>
  <action>
Create src/video/ directory and __init__.py with module exports.

Create src/video/quality.py with:

1. QualityConfig dataclass with fields:
   - resolution: tuple[int, int] (width, height)
   - bitrate: int (kbps)
   - framerate: int (default 30)
   - preset: str (ultrafast, fast, medium - FFmpeg encoding speed preset)
   - latency_mode: str ('low' or 'normal')

2. QUALITY_PRESETS dictionary with three presets matching research recommendations:

   '1080p': {
     resolution: (1920, 1080),
     bitrate: 5000,
     framerate: 30,
     preset: 'medium',
     latency_mode: 'normal'
   }

   '720p': {
     resolution: (1280, 720),
     bitrate: 2500,
     framerate: 30,
     preset: 'fast',
     latency_mode: 'normal'
   }

   'low-latency': {
     resolution: (1280, 720),
     bitrate: 2000,
     framerate: 30,
     preset: 'ultrafast',  # Sacrifices compression for speed
     latency_mode: 'low'
   }

3. Helper function get_quality_config(preset_name: str) -> QualityConfig that returns preset or raises ValueError for unknown names.

Use @dataclass decorator from dataclasses module for QualityConfig.
  </action>
  <verify>python -c "from src.video.quality import QualityConfig, QUALITY_PRESETS, get_quality_config; print(get_quality_config('1080p'))"</verify>
  <done>Quality configuration module exists with QualityConfig dataclass, QUALITY_PRESETS dict with 3 presets, and get_quality_config helper function</done>
</task>

<task type="auto">
  <name>Task 2: Implement FFmpeg encoder with quality configuration</name>
  <files>src/video/encoder.py, requirements.txt</files>
  <action>
Create src/video/encoder.py with FFmpegEncoder class using async context manager pattern (like BrowserManager and CastSessionManager from prior phases).

Class structure:

class FFmpegEncoder:
    """Manages FFmpeg encoding process for video streaming.

    Captures video from Xvfb virtual display and encodes to H.264 with
    configurable quality settings. Uses async context manager for proper
    process lifecycle management.

    Usage:
        config = get_quality_config('1080p')
        async with FFmpegEncoder(config, display=':99') as encoder:
            stream_url = await encoder.start_encoding()
            # Encoding runs until context exit
    """

Methods:

1. __init__(self, quality: QualityConfig, display: str = ':99', output_dir: str = '/tmp/streams'):
   - Store quality config, display number, output directory
   - Initialize process handle to None
   - Create output directory if missing

2. build_ffmpeg_args(self, output_file: str) -> list[str]:
   - Construct FFmpeg argument list based on quality config
   - Input: x11grab from display (-f x11grab -i {display})
   - Video size: -video_size {width}x{height}
   - Framerate: -framerate {framerate}
   - Codec: -c:v libx264 -preset {preset}
   - Bitrate: -b:v {bitrate}k -maxrate {bitrate}k -bufsize {bitrate*2}k
   - If latency_mode == 'low': add -tune zerolatency -bf 0 -refs 1 -g {framerate} -max_delay 0
   - If latency_mode == 'normal': add -g {framerate*2} -bf 2 -refs 3
   - Output format: -f hls -hls_time 2 -hls_list_size 3 -hls_flags delete_segments {output_file}
   - Return list of args (don't include 'ffmpeg' command itself)

3. async __aenter__(self) -> str:
   - Generate unique output filename: f"stream_{uuid4().hex}.m3u8"
   - Build full output path
   - Build FFmpeg args using build_ffmpeg_args
   - Start FFmpeg subprocess with asyncio.create_subprocess_exec
   - Capture stdout/stderr for logging
   - Wait 2 seconds for HLS playlist to be created
   - Check output file exists, raise if not
   - Log success with output path
   - Store process handle
   - Return HTTP URL for the m3u8 file (will be served by separate HTTP server in Phase 4)

4. async __aexit__(self, exc_type, exc_val, exc_tb):
   - Terminate FFmpeg process gracefully (process.terminate(), wait 5s)
   - If still running, kill forcefully (process.kill())
   - Clean up output files
   - Log cleanup complete

Error handling:
- Check for ffmpeg availability in PATH during __aenter__
- Log FFmpeg stderr output for debugging
- Handle process spawn failures gracefully
- Don't suppress exceptions in __aexit__

Add requirements.txt entry if missing: (no new Python packages needed - FFmpeg installed in Docker)
  </action>
  <verify>python -c "import asyncio; from src.video.encoder import FFmpegEncoder; from src.video.quality import get_quality_config; asyncio.run((lambda: print('FFmpegEncoder imports successfully'))())"</verify>
  <done>FFmpegEncoder class exists with async context manager, build_ffmpeg_args method constructs correct parameters for each latency mode, process lifecycle managed properly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Quality presets loadable and contain correct resolution/bitrate values
- [ ] FFmpegEncoder can be instantiated with quality config
- [ ] FFmpeg args include correct encoding parameters for low-latency vs normal
- [ ] Context manager pattern matches established patterns from Phases 1 and 2
- [ ] No import errors or missing dependencies
</verification>

<success_criteria>

- All tasks completed without errors
- Quality configuration module exists with 3 presets
- FFmpeg encoder module exists with async context manager
- Encoder builds correct FFmpeg arguments based on quality config
- Low-latency mode includes zerolatency tuning flags
- Code follows established async patterns from prior phases
  </success_criteria>

<output>
After completion, create `.planning/phases/03-video-pipeline/03-01-SUMMARY.md`
</output>
