---
phase: 02-cast-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - src/cast/__init__.py
  - src/cast/discovery.py
  - src/cast/session.py
autonomous: true

must_haves:
  truths:
    - "Service discovers Cast devices on local network"
    - "Service initiates Cast session to discovered device"
    - "Service stops active Cast session on command"
    - "TV wakes via HDMI-CEC when casting starts"
  artifacts:
    - path: "src/cast/discovery.py"
      provides: "Cast device discovery via mDNS"
      min_lines: 30
      exports: ["discover_devices", "get_cast_device"]
    - path: "src/cast/session.py"
      provides: "Cast session lifecycle management"
      min_lines: 60
      exports: ["CastSessionManager"]
    - path: "requirements.txt"
      provides: "pychromecast dependency"
      contains: "pychromecast"
  key_links:
    - from: "src/cast/discovery.py"
      to: "pychromecast"
      via: "import and use pychromecast.get_chromecasts()"
      pattern: "pychromecast\\.get_chromecasts"
    - from: "src/cast/session.py"
      to: "Cast device"
      via: "receive device from discovery, call device.wait()"
      pattern: "\\.wait\\(\\)"
    - from: "CastSessionManager.start()"
      to: "device wake"
      via: "HDMI-CEC wake before casting"
      pattern: "hdmi_cec_control"
---

<objective>
Implement Cast protocol connectivity with device discovery, session management, and HDMI-CEC wake capability using pychromecast library.

Purpose: Enable service to discover and connect to Android TV Cast devices on local network, establishing the foundation for video streaming in Phase 3.
Output: Cast module with discovery, session management, and HDMI-CEC wake support, ready for video stream integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-browser-foundation/01-01-SUMMARY.md
@.planning/phases/01-browser-foundation/01-02-SUMMARY.md

# Phase 1 established:
- Browser automation with Playwright
- Context manager pattern for resource lifecycle
- Docker with host networking (enables mDNS)
- Async/await patterns throughout

# Current source structure:
@src/browser/manager.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pychromecast dependency and create cast module structure</name>
  <files>requirements.txt, src/cast/__init__.py</files>
  <action>
    Add pychromecast>=13.0.0 to requirements.txt (latest stable version with HDMI-CEC support).

    Create src/cast/__init__.py exporting: discover_devices, get_cast_device, CastSessionManager.

    Follow Phase 1 pattern: clean module exports, prepare for discovery.py and session.py implementation.
  </action>
  <verify>
    - requirements.txt contains pychromecast>=13.0.0
    - src/cast/__init__.py exists with exports stub
    - pip install -r requirements.txt succeeds (no conflicts)
  </verify>
  <done>pychromecast dependency added, cast module structure created</done>
</task>

<task type="auto">
  <name>Task 2: Implement Cast device discovery via mDNS</name>
  <files>src/cast/discovery.py</files>
  <action>
    Create src/cast/discovery.py with two functions:

    1. discover_devices(timeout: int = 5) -> List[pychromecast.Chromecast]:
       - Use pychromecast.get_chromecasts() to discover Cast devices via mDNS
       - Timeout parameter controls discovery duration
       - Return list of discovered Chromecast objects
       - Log discovered devices (friendly_name, uuid, host)
       - Handle discovery failures gracefully (empty list, not exception)

    2. get_cast_device(device_name: str = None, timeout: int = 5) -> Optional[pychromecast.Chromecast]:
       - If device_name provided, search for specific device by friendly_name
       - If device_name None, return first discovered device
       - Use discover_devices() internally
       - Return None if not found (caller handles missing device)
       - Log which device was selected

    Use async/await pattern from Phase 1. Add proper error handling and logging.

    CRITICAL: Do NOT use blocking discovery in async context - wrap pychromecast calls properly or use run_in_executor if needed.
  </action>
  <verify>
    - Import discover_devices, get_cast_device succeeds
    - Functions have correct signatures with Optional/List types
    - No syntax errors: python -m py_compile src/cast/discovery.py
    - Logging statements present for discovery events
  </verify>
  <done>Cast device discovery implemented with mDNS scanning and device selection</done>
</task>

<task type="auto">
  <name>Task 3: Implement Cast session manager with HDMI-CEC wake</name>
  <files>src/cast/session.py</files>
  <action>
    Create src/cast/session.py with CastSessionManager class using context manager pattern from Phase 1.

    Class structure:
    ```python
    class CastSessionManager:
        def __init__(self, device: pychromecast.Chromecast):
            self.device = device
            self.is_active = False

        async def __aenter__(self):
            # Wake TV via HDMI-CEC using device.set_volume_muted(False) or equivalent
            # Wait for device ready: self.device.wait()
            # Mark session active
            # Log session start
            return self

        async def __aexit__(self, exc_type, exc_val, exc_tb):
            # Stop casting: disconnect from device
            # Mark session inactive
            # Log session end
            # Ensure cleanup happens even on exception

        def start_cast(self, media_url: str):
            # Placeholder for Phase 3 video streaming
            # For now, just verify device is ready and log
            pass

        def stop_cast(self):
            # Stop active media playback
            # Disconnect cast session
            self.is_active = False
    ```

    HDMI-CEC wake: Use device.set_volume_muted(False) or device.volume_up() to trigger HDMI-CEC wake (pychromecast built-in behavior).

    Follow Phase 1 patterns: context manager, async, logging, proper resource cleanup.
  </action>
  <verify>
    - CastSessionManager class exists with __aenter__ and __aexit__
    - Methods: start_cast, stop_cast defined
    - Import succeeds: from src.cast.session import CastSessionManager
    - No syntax errors: python -m py_compile src/cast/session.py
  </verify>
  <done>Cast session manager implemented with HDMI-CEC wake and context manager lifecycle</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All imports work: from src.cast import discover_devices, get_cast_device, CastSessionManager
- [ ] No syntax errors: python -m py_compile src/cast/*.py
- [ ] requirements.txt contains pychromecast>=13.0.0
- [ ] Module follows Phase 1 patterns (context manager, async, logging)
- [ ] HDMI-CEC wake logic present in CastSessionManager.__aenter__
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Cast module exports device discovery and session management
- HDMI-CEC wake capability implemented
- Code follows Phase 1 established patterns
- Ready for retry mechanism integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/02-cast-integration/02-01-SUMMARY.md`
</output>
