---
phase: 10-intel-quicksync-hardware-acceleration
plan: 03
type: execute
wave: 2
depends_on: ["10-02"]
files_modified:
  - src/video/encoder.py
  - src/api/routes.py
  - src/api/models.py
autonomous: true

must_haves:
  truths:
    - FFmpeg encoder uses h264_qsv when QuickSync available
    - FFmpeg encoder falls back to libx264 when QuickSync unavailable
    - Health endpoint reports hardware acceleration status
    - Encoder command uses correct rate control for each encoder type
  artifacts:
    - path: src/video/encoder.py
      provides: Hardware-aware encoder configuration
      contains: "HardwareAcceleration"
    - path: src/api/routes.py
      provides: Health endpoint with hardware status
      contains: "hardware_acceleration"
    - path: src/api/models.py
      provides: HealthResponse schema with hardware field
      contains: "hardware_acceleration"
  key_links:
    - from: src/video/encoder.py
      to: src/video/hardware.py
      via: import HardwareAcceleration
      pattern: "from \\.hardware import HardwareAcceleration"
    - from: src/video/encoder.py
      to: encoder selection logic
      via: get_encoder_config()
      pattern: "hw_accel\\.get_encoder_config"
    - from: src/api/routes.py
      to: HardwareAcceleration
      via: health check status
      pattern: "is_qsv_available"
---

<objective>
Integrate Intel QuickSync hardware acceleration into FFmpeg encoder with graceful fallback, and expose hardware status via health endpoint.

Purpose: Reduces CPU usage by 80-90% when QuickSync available, while maintaining service reliability via automatic software encoding fallback
Output: Encoder uses h264_qsv on supported hardware, health endpoint reports acceleration status
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-intel-quicksync-hardware-acceleration/10-RESEARCH.md

# Dependencies
@.planning/phases/10-intel-quicksync-hardware-acceleration/10-02-SUMMARY.md

# Files to modify
@src/video/encoder.py
@src/api/routes.py
@src/api/models.py
</context>

<tasks>

<task type="auto">
  <name>Integrate HardwareAcceleration into encoder</name>
  <files>src/video/encoder.py</files>
  <action>
Update FFmpegEncoder class to use HardwareAcceleration for encoder selection.

**Step 1: Add import**
Add to imports section (after existing imports):
```python
from .hardware import HardwareAcceleration
```

**Step 2: Add hw_accel instance**
In __init__ method, after self.log_task = None (line 65):
```python
self.hw_accel = HardwareAcceleration()  # Detect QuickSync availability
self.encoder = None  # Store encoder name for logging in __aenter__
```

**Step 3: Modify build_ffmpeg_args signature and logic**
Current signature (line 82):
```python
def build_ffmpeg_args(self, output_file: str) -> list[str]:
```

Change video codec section (currently lines 112-118) from:
```python
# Video codec and encoding settings
'-c:v', 'libx264',
'-pix_fmt', 'yuv420p',
'-preset', preset,
'-b:v', f'{bitrate}k',
'-maxrate', f'{bitrate}k',
'-bufsize', f'{bitrate * 2}k',
```

To:
```python
# Video codec and encoding settings (hardware-aware)
encoder_config = self.hw_accel.get_encoder_config()
self.encoder = encoder_config['encoder']  # Store for logging

'-c:v', self.encoder,
'-pix_fmt', 'yuv420p',
```

**Step 4: Add conditional rate control configuration**
After the '-pix_fmt', 'yuv420p' line, add encoder-specific settings:

```python
# Encoder-specific rate control
if self.encoder == 'h264_qsv':
    # QuickSync: Use ICQ mode with look_ahead
    args.extend(encoder_config['encoder_args'])
    # Note: global_quality replaces bitrate/preset for QSV
else:
    # libx264: Use existing bitrate/preset configuration
    args.extend([
        '-preset', preset,
        '-b:v', f'{bitrate}k',
        '-maxrate', f'{bitrate}k',
        '-bufsize', f'{bitrate * 2}k',
    ])
```

**Step 5: Update logging to show encoder type**
Update logger.info call in __aenter__ (around line 241-244) to include encoder using self.encoder:
```python
logger.info(
    f"Starting FFmpeg encoder: {self.encoder} @ {self.quality.resolution[0]}x{self.quality.resolution[1]} "
    f"{self.quality.bitrate}kbps, preset={self.quality.preset}, "
    f"latency_mode={self.quality.latency_mode}, mode={self.mode}"
)
```

**Rationale for self.encoder instance variable:**
The encoder name is determined in build_ffmpeg_args() but needed later in __aenter__() for logging. Storing as self.encoder (set in Step 2 and assigned in Step 3) ensures the variable is in scope for both methods. This avoids passing the encoder name through method parameters and maintains clean separation of concerns.

Reference: RESEARCH.md "Pattern 3: Encoder-Agnostic FFmpeg Arguments" (lines 174-225).

DO NOT remove existing latency_mode conditional logic (lines 133-148) - keep low-latency tuning.
DO NOT use -b:v with h264_qsv when using global_quality (they conflict).
DO NOT change audio codec settings or output format sections.
  </action>
  <verify>
python -c "from src.video.encoder import FFmpegEncoder; from src.video.quality import get_quality_config; enc = FFmpegEncoder(get_quality_config('720p')); args = enc.build_ffmpeg_args('/tmp/test.m3u8'); print('h264_qsv' if 'h264_qsv' in args else 'libx264', 'found in args'); print(f'Encoder variable: {enc.encoder}')"
  </verify>
  <done>encoder.py imports HardwareAcceleration, __init__ creates hw_accel instance and self.encoder variable, build_ffmpeg_args uses encoder from get_encoder_config() and stores in self.encoder, rate control conditional on encoder type, logging in __aenter__ uses self.encoder</done>
</task>

<task type="auto">
  <name>Update health endpoint with hardware status</name>
  <files>src/api/routes.py, src/api/models.py</files>
  <action>
Expose hardware acceleration status via /health endpoint.

**File 1: src/api/models.py**

Locate HealthResponse model (should be with other response models).

Add hardware_acceleration field to HealthResponse:
```python
class HealthResponse(BaseModel):
    status: str
    active_streams: int
    cast_device: str
    hardware_acceleration: dict  # NEW: QuickSync status
```

**File 2: src/api/routes.py**

Add import at top:
```python
from src.video.hardware import HardwareAcceleration
```

Locate health_check function (around line 89-105).

Update to instantiate HardwareAcceleration and include status:
```python
@app.get("/health", response_model=HealthResponse)
async def health_check():
    """Health check for monitoring.

    Checks Cast device availability, active streams, and hardware acceleration status.
    """
    # Check Cast device
    device = await get_cast_device()
    device_available = device is not None

    # Check hardware acceleration
    hw_accel = HardwareAcceleration()
    encoder_config = hw_accel.get_encoder_config()

    status = "healthy" if device_available else "degraded"

    return HealthResponse(
        status=status,
        active_streams=len(app.state.stream_tracker.active_tasks),
        cast_device="available" if device_available else "unavailable",
        hardware_acceleration={
            "quicksync_available": hw_accel.is_qsv_available(),
            "encoder": encoder_config['encoder']
        }
    )
```

Reference: RESEARCH.md "Health Check - Hardware Status Endpoint" code example (lines 406-424).

DO NOT change existing status logic or cast_device checking.
DO NOT modify other endpoints (/start, /stop, /status).
  </action>
  <verify>
python -c "from src.api.models import HealthResponse; resp = HealthResponse(status='healthy', active_streams=0, cast_device='available', hardware_acceleration={'quicksync_available': False, 'encoder': 'libx264'}); print(resp.model_dump())"
  </verify>
  <done>HealthResponse model includes hardware_acceleration field, health_check endpoint creates HardwareAcceleration instance and returns QuickSync status with encoder name</done>
</task>

</tasks>

<verification>
Overall verification:
- encoder.py imports and uses HardwareAcceleration class
- build_ffmpeg_args() selects encoder based on hardware availability and stores in self.encoder
- Rate control arguments conditional on encoder type (global_quality for QSV, bitrate for libx264)
- __aenter__() logging uses self.encoder instance variable
- Health endpoint returns hardware acceleration status
- HealthResponse model includes hardware_acceleration field
</verification>

<success_criteria>
- FFmpegEncoder class creates HardwareAcceleration instance in __init__
- FFmpegEncoder __init__ declares self.encoder instance variable for cross-method access
- build_ffmpeg_args() calls get_encoder_config() to determine encoder and stores in self.encoder
- h264_qsv uses ICQ mode (global_quality + look_ahead) from encoder_config
- libx264 uses existing bitrate/preset configuration
- Logger output in __aenter__() includes encoder name from self.encoder
- /health endpoint returns hardware_acceleration dict with quicksync_available and encoder fields
- HealthResponse model schema includes hardware_acceleration field
</success_criteria>

<output>
After completion, create `.planning/phases/10-intel-quicksync-hardware-acceleration/10-03-SUMMARY.md`
</output>
