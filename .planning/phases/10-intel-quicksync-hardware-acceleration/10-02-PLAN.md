---
phase: 10-intel-quicksync-hardware-acceleration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/video/hardware.py
autonomous: false

must_haves:
  truths:
    - Service detects QuickSync availability at runtime without errors
    - Detection returns false gracefully when hardware unavailable
    - Detection returns correct encoder configuration (h264_qsv vs libx264)
  artifacts:
    - path: src/video/hardware.py
      provides: Hardware detection and encoder configuration
      min_lines: 100
      exports: ["HardwareAcceleration"]
  key_links:
    - from: src/video/hardware.py
      to: vainfo command
      via: subprocess.run
      pattern: "subprocess\\.run.*vainfo"
    - from: src/video/hardware.py
      to: ffmpeg -encoders
      via: subprocess.run
      pattern: "subprocess\\.run.*ffmpeg.*-encoders"
---

<objective>
Create hardware detection module that identifies Intel QuickSync availability at runtime and provides encoder configuration with graceful fallback to software encoding.

Purpose: Enables runtime detection of h264_qsv encoder and /dev/dri device access, allowing service to adapt based on available hardware
Output: HardwareAcceleration class with detection logic and encoder configuration
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-intel-quicksync-hardware-acceleration/10-RESEARCH.md

# Prior implementation context
@.planning/phases/03-video-pipeline/03-01-SUMMARY.md

# Current encoder implementation
@src/video/encoder.py
</context>

<tasks>

<task type="auto">
  <name>Create hardware detection module</name>
  <files>src/video/hardware.py</files>
  <action>
Create new file src/video/hardware.py implementing HardwareAcceleration class with runtime detection.

Use the "Hardware Detection with Graceful Fallback" pattern from RESEARCH.md as the foundation.

Class structure:
```python
"""Hardware acceleration detection and configuration for FFmpeg.

Detects Intel QuickSync (h264_qsv) availability at runtime and provides
encoder configuration with graceful fallback to software encoding.
"""

import logging
import subprocess
from typing import TypedDict

logger = logging.getLogger(__name__)


class EncoderConfig(TypedDict):
    """Encoder configuration dictionary."""
    encoder: str  # 'h264_qsv' or 'libx264'
    encoder_args: list[str]  # Encoder-specific arguments


class HardwareAcceleration:
    """Detect and configure hardware acceleration for FFmpeg."""

    def __init__(self):
        self._qsv_available = None

    def is_qsv_available(self) -> bool:
        """Check if Intel QuickSync h264_qsv encoder is available.

        Detection method:
        1. Check ffmpeg -encoders for h264_qsv
        2. Verify /dev/dri/renderD128 accessible via vainfo
        3. Confirm VAEntrypointEncSlice capability exists

        Returns cached result on subsequent calls.

        Returns:
            True if h264_qsv encoder available, False otherwise
        """
        # Return cached result if already checked
        if self._qsv_available is not None:
            return self._qsv_available

        try:
            # Step 1: Check if ffmpeg has h264_qsv encoder
            result = subprocess.run(
                ['ffmpeg', '-encoders'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=5,
                errors='replace'
            )

            if result.returncode != 0:
                logger.warning("FFmpeg -encoders command failed, falling back to software encoding")
                self._qsv_available = False
                return False

            if 'h264_qsv' not in result.stdout:
                logger.warning("h264_qsv encoder not found in FFmpeg, falling back to software encoding")
                self._qsv_available = False
                return False

            # Step 2: Verify /dev/dri/renderD128 access via vainfo
            result = subprocess.run(
                ['vainfo', '--display', 'drm', '--device', '/dev/dri/renderD128'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=5,
                errors='replace'
            )

            if result.returncode != 0:
                logger.warning(
                    "vainfo command failed (GPU device not accessible), "
                    "falling back to software encoding"
                )
                self._qsv_available = False
                return False

            # Step 3: Check for VAEntrypointEncSlice capability (H.264 encoding support)
            output = result.stdout + result.stderr
            if 'VAEntrypointEncSlice' not in output:
                logger.warning(
                    "VAEntrypointEncSlice not found (GPU doesn't support encoding), "
                    "falling back to software encoding"
                )
                self._qsv_available = False
                return False

            # All checks passed
            logger.info("Intel QuickSync h264_qsv encoder available and accessible")
            self._qsv_available = True
            return True

        except FileNotFoundError as e:
            logger.warning(f"Required command not found ({e.filename}), falling back to software encoding")
            self._qsv_available = False
            return False

        except subprocess.TimeoutExpired:
            logger.warning("Hardware detection timed out, falling back to software encoding")
            self._qsv_available = False
            return False

        except Exception as e:
            logger.warning(f"Unexpected error during hardware detection: {e}, falling back to software encoding")
            self._qsv_available = False
            return False

    def get_encoder_config(self) -> EncoderConfig:
        """Get encoder configuration based on hardware availability.

        Returns:
            EncoderConfig with encoder name and encoder-specific args
        """
        if self.is_qsv_available():
            return {
                'encoder': 'h264_qsv',
                'encoder_args': [
                    '-global_quality', '23',      # ICQ mode quality target (like CRF)
                    '-look_ahead', '1',           # Enable lookahead rate control
                    '-look_ahead_depth', '40',    # Analyze 40 frames ahead
                ]
            }
        else:
            return {
                'encoder': 'libx264',
                'encoder_args': []  # Use existing preset/bitrate config
            }
```

Implementation follows RESEARCH.md "Pattern 1: Hardware Detection with Graceful Fallback" (lines 72-150) exactly:
- subprocess.run() with timeout=5 for both ffmpeg and vainfo checks
- Check result.returncode == 0 before parsing stdout
- Use 'utf-8' text mode with errors='replace' for decoding
- Return False (not raise exceptions) when hardware unavailable
- Log at INFO level when QuickSync available, WARNING when falling back
- Cache result in self._qsv_available for subsequent calls

DO NOT hardcode /dev/dri/renderD128 checks without vainfo (vainfo handles device enumeration).
DO NOT mix rate control modes - use global_quality for QSV, not bitrate.
  </action>
  <verify>
python -c "from src.video.hardware import HardwareAcceleration; hw = HardwareAcceleration(); print(f'QSV: {hw.is_qsv_available()}, Encoder: {hw.get_encoder_config()}')"
  </verify>
  <done>hardware.py exists, imports successfully, is_qsv_available() returns bool, get_encoder_config() returns dict with encoder and encoder_args keys</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Hardware detection module that checks for Intel QuickSync availability via vainfo and ffmpeg -encoders.
  </what-built>
  <how-to-verify>
Test hardware detection in three scenarios:

**Scenario 1: Without GPU passthrough (should fallback)**
```bash
cd /root/claudeProjects/WSL/gsd-dashboard-cast
python3 -c "from src.video.hardware import HardwareAcceleration; hw = HardwareAcceleration(); print(f'QSV available: {hw.is_qsv_available()}'); config = hw.get_encoder_config(); print(f'Encoder: {config[\"encoder\"]}'); print(f'Args: {config[\"encoder_args\"]}')"
```

Expected output:
- QSV available: False
- Encoder: libx264
- Args: []
- Log should show WARNING about QuickSync not available

**Scenario 2: Build and test inside container (before GPU passthrough)**
```bash
docker build -t dashboard-cast .
docker run --rm dashboard-cast python3 -c "from src.video.hardware import HardwareAcceleration; hw = HardwareAcceleration(); print(f'QSV: {hw.is_qsv_available()}')"
```

Expected: False (no /dev/dri access yet)

**Scenario 3: If you have /dev/dri on host** (optional - may not exist in VM without passthrough)
```bash
# Check if /dev/dri exists on host
ls -l /dev/dri
vainfo --display drm --device /dev/dri/renderD128
```

If vainfo shows VAEntrypointEncSlice:
- Hardware detection should return True
- Encoder should be h264_qsv
- encoder_args should include global_quality, look_ahead

If /dev/dri doesn't exist: This is expected before Proxmox GPU passthrough is configured. Phase will document how to enable it.
  </how-to-verify>
  <resume-signal>
Confirm:
1. "fallback works" - Detection returns libx264 when QuickSync unavailable
2. "no errors" - Detection handles missing hardware gracefully (no exceptions)
3. Ready to proceed with encoder integration

Or describe any issues encountered.
  </resume-signal>
</task>

</tasks>

<verification>
Overall verification:
- src/video/hardware.py created and implements HardwareAcceleration class
- is_qsv_available() method checks ffmpeg -encoders and vainfo
- get_encoder_config() returns correct configuration based on hardware availability
- Detection works without /dev/dri (returns False gracefully)
- Human verified fallback behavior works correctly
</verification>

<success_criteria>
- HardwareAcceleration class detects h264_qsv encoder availability
- Detection uses vainfo to verify /dev/dri/renderD128 access and VAEntrypointEncSlice capability
- get_encoder_config() returns h264_qsv config when available, libx264 config when not
- QuickSync config uses ICQ mode (global_quality) with look_ahead enabled
- Software fallback config returns empty encoder_args (uses existing preset/bitrate from encoder.py)
- Detection handles missing hardware gracefully (no exceptions, logs warnings)
</success_criteria>

<output>
After completion, create `.planning/phases/10-intel-quicksync-hardware-acceleration/10-02-SUMMARY.md`
</output>
