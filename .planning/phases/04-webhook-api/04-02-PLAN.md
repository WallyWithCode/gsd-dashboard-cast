---
phase: 04-webhook-api
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [src/api/state.py, src/api/routes.py, src/api/main.py]
autonomous: true

must_haves:
  truths:
    - "POST /start creates background stream task"
    - "POST /stop cancels active stream"
    - "Concurrent /start requests handled with lock"
    - "Previous stream auto-stops when new /start arrives"
    - "All webhook events logged with structured context"
  artifacts:
    - path: "src/api/state.py"
      provides: "StreamTracker managing asyncio tasks"
      min_lines: 60
      exports: ["StreamTracker"]
    - path: "src/api/routes.py"
      provides: "Webhook endpoint handlers"
      min_lines: 80
      contains: "@app.post"
  key_links:
    - from: "routes.py /start"
      to: "StreamTracker.start_stream"
      via: "app.state.stream_tracker.start_stream()"
      pattern: "stream_tracker\\.start_stream"
    - from: "StreamTracker._run_stream"
      to: "StreamManager from Phase 3"
      via: "async with StreamManager"
      pattern: "StreamManager"
    - from: "routes.py /stop"
      to: "StreamTracker.stop_current_stream"
      via: "task.cancel() on active task"
      pattern: "stop_current_stream"
---

<objective>
Implement StreamTracker state management and core webhook endpoints with non-blocking async processing.

Purpose: Create the state management layer that tracks active streams and the webhook handlers that start/stop them, following the non-blocking pattern from research where endpoints return immediately while streams run in background.
Output: Working /start and /stop endpoints with proper state tracking and cleanup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-webhook-api/04-RESEARCH.md
@.planning/phases/04-webhook-api/04-CONTEXT.md
@.planning/phases/04-webhook-api/04-01-SUMMARY.md

# StreamManager from Phase 3 - we'll integrate with it
@src/video/stream.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StreamTracker for asyncio task management</name>
  <files>src/api/state.py</files>
  <action>
Create src/api/state.py with StreamTracker class following research (04-RESEARCH.md, Pattern 3):

```python
import asyncio
import structlog
from typing import Dict, Optional
from src.video.stream import StreamManager

logger = structlog.get_logger()

class StreamTracker:
    """Manages active streaming tasks with proper lifecycle and cleanup."""

    def __init__(self):
        self.active_tasks: Dict[str, asyncio.Task] = {}
        self.lock = asyncio.Lock()

    def has_active_stream(self) -> bool:
        return len(self.active_tasks) > 0

    def start_stream(self, session_id: str, url: str, quality: str, duration: Optional[int]) -> str:
        """Launch stream as background task."""
        task = asyncio.create_task(self._run_stream(session_id, url, quality, duration))
        self.active_tasks[session_id] = task
        logger.info("stream_task_created", session_id=session_id, url=url, quality=quality)
        return session_id

    async def _run_stream(self, session_id: str, url: str, quality: str, duration: Optional[int]):
        """Execute stream (runs until duration expires or cancelled)."""
        try:
            structlog.contextvars.bind_contextvars(
                session_id=session_id,
                url=url,
                quality=quality
            )

            stream_manager = StreamManager(url, quality, duration)
            async with stream_manager:
                await stream_manager.stream()

            logger.info("stream_completed", session_id=session_id)
        except asyncio.CancelledError:
            logger.info("stream_cancelled", session_id=session_id)
        except Exception as e:
            logger.error("stream_failed", session_id=session_id, error=str(e))
        finally:
            self.active_tasks.pop(session_id, None)
            structlog.contextvars.clear_contextvars()

    async def stop_current_stream(self):
        """Stop the active stream (single device, only one active)."""
        async with self.lock:
            if not self.active_tasks:
                return

            session_id, task = next(iter(self.active_tasks.items()))
            logger.info("stopping_stream", session_id=session_id)
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass

    async def cleanup_all(self):
        """Cancel all active streams on shutdown."""
        tasks = list(self.active_tasks.values())
        for task in tasks:
            task.cancel()
        await asyncio.gather(*tasks, return_exceptions=True)
        self.active_tasks.clear()
```

Use asyncio.create_task() for long-running streams (outlives request). Track tasks in dict for cleanup. Lock prevents race conditions on concurrent start/stop. Context variables for logging (session_id, url, quality bind to all logs in this stream).
  </action>
  <verify>
- StreamTracker imports successfully: `python -c "from src.api.state import StreamTracker"`
- Has required methods: has_active_stream, start_stream, stop_current_stream, cleanup_all
  </verify>
  <done>StreamTracker class manages asyncio tasks with proper tracking and cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Implement /start and /stop webhook endpoints</name>
  <files>src/api/routes.py</files>
  <action>
Create src/api/routes.py with webhook handlers following research (04-RESEARCH.md, Pattern 2 and 5):

```python
from fastapi import BackgroundTasks
import uuid
import structlog
from src.api.models import StartRequest, StartResponse, StopResponse

logger = structlog.get_logger()

def register_routes(app):
    """Register all webhook routes."""

    @app.post("/start", response_model=StartResponse)
    async def start_cast(request: StartRequest, background_tasks: BackgroundTasks):
        """Start casting with auto-stop of previous stream."""
        logger.info("webhook_start", url=str(request.url), quality=request.quality, duration=request.duration)

        # Auto-stop previous stream (seamless transition from CONTEXT.md)
        if app.state.stream_tracker.has_active_stream():
            await app.state.stream_tracker.stop_current_stream()

        # Start new stream in background
        session_id = str(uuid.uuid4())
        background_tasks.add_task(
            app.state.stream_tracker.start_stream,
            session_id,
            str(request.url),
            request.quality,
            request.duration
        )

        return StartResponse(status="success", session_id=session_id)

    @app.post("/stop", response_model=StopResponse)
    async def stop_cast():
        """Stop active casting session."""
        logger.info("webhook_stop")

        if not app.state.stream_tracker.has_active_stream():
            return StopResponse(status="success", message="No active stream")

        await app.state.stream_tracker.stop_current_stream()
        return StopResponse(status="success", message="Stream stopped")
```

Use BackgroundTasks for immediate response (non-blocking). Auto-stop previous stream before starting new (seamless transition). Generate session_id with uuid4. Log all webhook events with structured context.
  </action>
  <verify>
- routes.py imports successfully
- register_routes function exists
- /start and /stop handlers defined
  </verify>
  <done>Webhook endpoints implemented with non-blocking responses and auto-stop behavior</done>
</task>

<task type="auto">
  <name>Task 3: Wire StreamTracker into app lifespan and register routes</name>
  <files>src/api/main.py</files>
  <action>
Update src/api/main.py to initialize StreamTracker in lifespan and register routes:

```python
from src.api.state import StreamTracker
from src.api.routes import register_routes

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    configure_logging()
    logger.info("app_startup", phase="webhook-api")

    # Initialize StreamTracker
    app.state.stream_tracker = StreamTracker()

    yield

    # Shutdown: Cleanup active streams
    logger.info("app_shutdown", active_streams=len(app.state.stream_tracker.active_tasks))
    await app.state.stream_tracker.cleanup_all()

app = FastAPI(
    title="Dashboard Cast Service",
    version="1.0.0",
    lifespan=lifespan
)

# Register webhook routes
register_routes(app)
```

StreamTracker stored in app.state (singleton pattern). Cleanup called in shutdown phase to cancel all active tasks. Routes registered after app creation.
  </action>
  <verify>
- main.py imports StreamTracker and register_routes
- Lifespan creates stream_tracker in app.state
- Shutdown calls cleanup_all()
- register_routes(app) called
  </verify>
  <done>StreamTracker integrated into app lifecycle with routes registered</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] StreamTracker class exists with task management
- [ ] /start and /stop endpoints defined
- [ ] Routes registered with app
- [ ] Lifespan initializes and cleans up StreamTracker
- [ ] All imports resolve successfully
</verification>

<success_criteria>
- All tasks completed
- StreamTracker manages asyncio tasks with proper cleanup
- /start endpoint accepts requests and returns immediately
- /stop endpoint cancels active streams
- Auto-stop previous stream when new start arrives
- All webhook events logged with structured context
- Ready for status/health endpoints in Plan 03
</success_criteria>

<output>
After completion, create `.planning/phases/04-webhook-api/04-02-SUMMARY.md`
</output>
