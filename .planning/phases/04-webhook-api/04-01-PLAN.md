---
phase: 04-webhook-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/api/__init__.py, src/api/main.py, src/api/models.py, src/api/logging_config.py, requirements.txt]
autonomous: true

must_haves:
  truths:
    - "FastAPI app initializes with lifespan context manager"
    - "Structured JSON logging writes to stdout"
    - "Request/response models validate with Pydantic"
  artifacts:
    - path: "src/api/main.py"
      provides: "FastAPI app with lifespan for state management"
      min_lines: 30
      contains: "asynccontextmanager"
    - path: "src/api/models.py"
      provides: "Pydantic request/response models"
      exports: ["StartRequest", "StartResponse", "StatusResponse"]
    - path: "src/api/logging_config.py"
      provides: "structlog configuration with JSON output"
      contains: "structlog.configure"
  key_links:
    - from: "src/api/main.py"
      to: "structlog"
      via: "import and configure in lifespan"
      pattern: "configure_logging"
---

<objective>
Establish FastAPI foundation with lifespan, structured logging, and request/response models.

Purpose: Create the web framework foundation that all webhook endpoints will use, including proper async lifecycle management and JSON logging for production debugging.
Output: Working FastAPI app that starts/stops cleanly with structured logging configured.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-webhook-api/04-RESEARCH.md
@.planning/phases/04-webhook-api/04-CONTEXT.md

# Phase 3 provided StreamManager - we'll integrate with it in Plan 02
@.planning/phases/03-video-pipeline/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI app with lifespan context manager</name>
  <files>src/api/__init__.py, src/api/main.py</files>
  <action>
Create src/api/ directory structure with __init__.py. In main.py, create FastAPI app using the lifespan pattern from research (04-RESEARCH.md, Pattern 1):

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
import structlog

logger = structlog.get_logger()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Configure logging, initialize state
    configure_logging()
    logger.info("app_startup", phase="webhook-api")

    # Future: Initialize StreamTracker here (Plan 02)
    yield

    # Shutdown: Cleanup
    logger.info("app_shutdown")
    # Future: Cleanup active streams (Plan 02)

app = FastAPI(
    title="Dashboard Cast Service",
    version="1.0.0",
    lifespan=lifespan
)
```

Use lifespan (NOT deprecated @app.on_event). This ensures startup/shutdown logic stays together and resources are properly cleaned up.
  </action>
  <verify>
- Python can import: `python -c "from src.api.main import app; print(app.title)"`
- App has lifespan: grep "asynccontextmanager" src/api/main.py
  </verify>
  <done>FastAPI app exists with lifespan context manager configured for startup/shutdown</done>
</task>

<task type="auto">
  <name>Task 2: Configure structured logging with structlog</name>
  <files>src/api/logging_config.py, requirements.txt</files>
  <action>
Add structlog to requirements.txt (version 25.5+).

Create src/api/logging_config.py following research (04-RESEARCH.md, Pattern 4):

```python
import logging
import structlog

def configure_logging():
    structlog.configure(
        processors=[
            structlog.contextvars.merge_contextvars,
            structlog.processors.add_log_level,
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.JSONRenderer()
        ],
        wrapper_class=structlog.make_filtering_bound_logger(logging.INFO),
        context_class=dict,
        logger_factory=structlog.PrintLoggerFactory(),
        cache_logger_on_first_use=True
    )
```

JSON output for production log aggregation. ISO timestamps. Context variables for request tracking (session_id, url, quality).

Import and call configure_logging() in main.py lifespan startup.
  </action>
  <verify>
- requirements.txt contains "structlog>=25.5.0"
- logging_config.py exists with configure_logging function
- main.py imports and calls configure_logging()
  </verify>
  <done>Structured JSON logging configured, logs written to stdout in JSON format</done>
</task>

<task type="auto">
  <name>Task 3: Create Pydantic request/response models</name>
  <files>src/api/models.py</files>
  <action>
Create src/api/models.py with Pydantic v2 models:

```python
from pydantic import BaseModel, HttpUrl, Field
from typing import Optional

class StartRequest(BaseModel):
    url: HttpUrl
    quality: str = "1080p"  # Default from Docker config
    duration: Optional[int] = None  # Seconds, None = indefinite

class StartResponse(BaseModel):
    status: str
    session_id: str

class StopResponse(BaseModel):
    status: str
    message: str

class StatusResponse(BaseModel):
    status: str  # "casting" or "idle"
    stream: Optional[dict] = None  # {session_id, started_at, url, quality} if active

class HealthResponse(BaseModel):
    status: str  # "healthy" or "degraded"
    active_streams: int
    cast_device: str  # "available" or "unavailable"
```

Use HttpUrl for validation (rejects non-HTTPS if we add that constraint later). Quality has default matching Docker config pattern from CONTEXT.md. Duration optional for indefinite streams.
  </action>
  <verify>
- src/api/models.py imports successfully
- All models have proper type hints: `python -c "from src.api.models import StartRequest, StartResponse, StopResponse, StatusResponse, HealthResponse"`
  </verify>
  <done>Pydantic models defined for all request/response contracts with validation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] FastAPI app imports successfully
- [ ] Lifespan function exists and is connected to app
- [ ] structlog configures on import
- [ ] All Pydantic models import without errors
- [ ] No import errors when loading main.py
</verification>

<success_criteria>
- All tasks completed
- FastAPI app exists with proper lifespan pattern
- Structured logging configured for JSON output
- Request/response models validated with Pydantic
- Foundation ready for endpoint implementation in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/04-webhook-api/04-01-SUMMARY.md`
</output>
