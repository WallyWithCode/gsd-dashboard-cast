---
phase: 09-hls-buffering-fix
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - src/video/encoder.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "FFmpeg encoding progress visible in application logs"
    - "FFmpeg warnings and errors logged during streaming"
    - "Encoding failures diagnosable from log output"
  artifacts:
    - path: "src/video/encoder.py"
      provides: "FFmpeg stdout/stderr log forwarding"
      min_lines: 320
      contains: "_log_ffmpeg_output"
  key_links:
    - from: "FFmpegEncoder.__aenter__"
      to: "_log_ffmpeg_output asyncio task"
      via: "asyncio.create_task after process start"
      pattern: "asyncio\\.create_task.*_log_ffmpeg_output"
---

<objective>
Add FFmpeg subprocess log forwarding to capture encoding output in application logs.

Purpose: Closes GAP-09-01 by forwarding FFmpeg's stdout and stderr to application logs, enabling diagnosis of streaming failures, verification of HLS segment creation, and monitoring of encoding health.

Output: FFmpeg process output captured and logged with appropriate severity levels, providing visibility into encoding operations and errors.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/root/claudeProjects/WSL/gsd-dashboard-cast/.planning/PROJECT.md
@/root/claudeProjects/WSL/gsd-dashboard-cast/.planning/ROADMAP.md
@/root/claudeProjects/WSL/gsd-dashboard-cast/.planning/STATE.md
@/root/claudeProjects/WSL/gsd-dashboard-cast/.planning/phases/09-hls-buffering-fix/09-VERIFICATION.md
@/root/claudeProjects/WSL/gsd-dashboard-cast/.planning/phases/09-hls-buffering-fix/09-01-SUMMARY.md

## Gap Context

**GAP-09-01: FFmpeg Subprocess Logging Not Captured**

From verification testing:
- User observed stream played briefly then went to black screen
- No FFmpeg logs available to diagnose root cause
- FFmpeg stdout/stderr are piped (lines 204-209) but never read during normal operation
- Only read in error cases (startup failures)
- Blocks verification of HLS-01 (continuous playback) and HLS-02 (buffer maintenance)

**What's needed:**
1. Async task to read FFmpeg stdout/stderr continuously
2. Forward FFmpeg output to application logger with appropriate levels
3. Task lifecycle management (start after process creation, cancel on cleanup)

**Current implementation:**
```python
# Lines 204-209 in encoder.py
self.process = await asyncio.create_subprocess_exec(
    'ffmpeg',
    *args,
    stdout=asyncio.subprocess.PIPE,
    stderr=asyncio.subprocess.PIPE
)
```

Output is piped but never consumed. Need background task to read streams.

@/root/claudeProjects/WSL/gsd-dashboard-cast/src/video/encoder.py
</context>

<tasks>

<task type="auto">
  <name>Add FFmpeg log forwarding method</name>
  <files>src/video/encoder.py</files>
  <action>
Add a new private async method `_log_ffmpeg_output` to FFmpegEncoder class to continuously read and log FFmpeg's stderr output.

Insert this method after `build_ffmpeg_args` method (around line 180, before `__aenter__`):

```python
async def _log_ffmpeg_output(self):
    """Read FFmpeg stderr and forward to application logs.

    FFmpeg writes all output (progress, warnings, errors) to stderr.
    This task runs in the background during encoding to capture output.
    """
    if not self.process or not self.process.stderr:
        return

    try:
        while True:
            # Read line from stderr
            line = await self.process.stderr.readline()
            if not line:
                # EOF reached, process terminated
                break

            # Decode and strip whitespace
            output = line.decode('utf-8', errors='replace').strip()

            if not output:
                continue

            # Log with appropriate level based on content
            # FFmpeg uses stderr for all output, not just errors
            if 'error' in output.lower():
                logger.error(f"FFmpeg: {output}")
            elif 'warning' in output.lower():
                logger.warning(f"FFmpeg: {output}")
            elif output.startswith('frame=') or output.startswith('size='):
                # Encoding progress updates - debug level to avoid spam
                logger.debug(f"FFmpeg: {output}")
            else:
                # General info (stream mapping, codec info, etc.)
                logger.info(f"FFmpeg: {output}")

    except asyncio.CancelledError:
        # Task cancelled during cleanup - normal behavior
        logger.debug("FFmpeg log forwarding cancelled")
        raise
    except Exception as e:
        logger.error(f"Error reading FFmpeg output: {e}")
```

**Why stderr only:** FFmpeg writes all output (progress, errors, warnings, codec info) to stderr by default. Stdout contains only the actual encoded stream data when output is a pipe, which is not the case here (we output to files).

**Level logic:**
- ERROR: Lines containing "error" (encoding failures, I/O errors)
- WARNING: Lines containing "warning" (codec issues, deprecated options)
- DEBUG: Progress updates (frame=, size=, time=) to avoid log spam
- INFO: Everything else (codec selection, stream mapping, segment creation)
  </action>
  <verify>
1. Check method added correctly:
   ```bash
   grep -A 30 "async def _log_ffmpeg_output" /root/claudeProjects/WSL/gsd-dashboard-cast/src/video/encoder.py
   ```

2. Verify imports are sufficient (asyncio should already be imported):
   ```bash
   grep "^import asyncio" /root/claudeProjects/WSL/gsd-dashboard-cast/src/video/encoder.py
   ```
  </verify>
  <done>
- `_log_ffmpeg_output` method added to FFmpegEncoder class
- Method implements async readline loop with level-based logging
- CancelledError handling for graceful shutdown
  </done>
</task>

<task type="auto">
  <name>Start log forwarding task and manage lifecycle</name>
  <files>src/video/encoder.py</files>
  <action>
**IMPORTANT:** This task modifies encoder.py AFTER Plan 09-01's changes. Line numbers referenced here are approximate and must be verified by reading the file first to account for 09-01's modifications (startup cleanup, HLS config changes, exit cleanup additions).

1. Add instance variable to track log task in `__init__` method (around line 65-70, with other instance vars like self.process, self.quality_config):
   ```python
   self.log_task = None  # Background task for FFmpeg output logging
   ```

2. Start log forwarding task in `__aenter__` after FFmpeg process starts (look for "FFmpeg process started" log line, add AFTER that):
   ```python
   # Start background task to forward FFmpeg output to logs
   self.log_task = asyncio.create_task(self._log_ffmpeg_output())
   ```

3. Cancel log task in `__aexit__` cleanup BEFORE process termination (look for "Stopping FFmpeg process" log line and the subsequent `self.process.terminate()` call, insert cancellation BEFORE terminate()):
   ```python
   # Cancel log forwarding task before terminating process
   # This must happen BEFORE terminate() to prevent reading from a closed pipe
   if self.log_task and not self.log_task.done():
       self.log_task.cancel()
       try:
           await self.log_task
       except asyncio.CancelledError:
           pass  # Expected cancellation
   ```

**CRITICAL PLACEMENT:** The log task cancellation MUST be placed BEFORE `self.process.terminate()`. The correct sequence is:

```python
# Find: logger.info(f"Stopping FFmpeg process (PID: {self.process.pid})")
# INSERT CANCELLATION HERE (before process.terminate())
# Find: self.process.terminate()
```

**Why this order matters:**
- `process.terminate()` sends SIGTERM to FFmpeg, which triggers stderr pipe closure
- If the log task is still reading when the pipe closes, it gets EOF (clean break)
- If we cancel AFTER terminate, there's a race: task might try reading from closed pipe and get BrokenPipeError
- Cancelling BEFORE terminate ensures clean shutdown: cancel task → wait for task → then terminate process

**Lifecycle:**
- Task created after FFmpeg process starts (has stderr stream to read)
- Runs in background throughout encoding session
- Cancelled BEFORE FFmpeg termination to ensure clean pipe closure
- CancelledError caught and suppressed (normal cleanup behavior)
  </action>
  <verify>
1. Verify instance variable added:
   ```bash
   grep "self.log_task" /root/claudeProjects/WSL/gsd-dashboard-cast/src/video/encoder.py
   ```
   Should show initialization in __init__, create_task in __aenter__, and cancellation in __aexit__.

2. Verify task cancellation is BEFORE process.terminate():
   ```bash
   sed -n '/Stopping FFmpeg process/,/process\.terminate()/p' /root/claudeProjects/WSL/gsd-dashboard-cast/src/video/encoder.py | grep -B5 "process\.terminate()"
   ```
   Should show log_task.cancel() block appears BEFORE process.terminate() line.

3. Run syntax check:
   ```bash
   python3 -c "import ast; ast.parse(open('/root/claudeProjects/WSL/gsd-dashboard-cast/src/video/encoder.py').read())"
   echo $?
   ```
   Should output 0 (no syntax errors).

4. Run tests to verify no regressions:
   ```bash
   cd /root/claudeProjects/WSL/gsd-dashboard-cast
   python3 -m pytest tests/ -v -k encoder
   ```
  </verify>
  <done>
- `self.log_task` instance variable added to track background task
- Log task started after FFmpeg process creation
- Log task cancelled in cleanup BEFORE process termination (correct order verified)
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Test FFmpeg log forwarding with local encoding</name>
  <files>src/video/encoder.py</files>
  <action>
Create a minimal test script to verify FFmpeg output is captured and logged:

Create `/tmp/test_ffmpeg_logging.py`:
```python
#!/usr/bin/env python3
import asyncio
import logging
import sys
import os

# Add src to path
sys.path.insert(0, '/root/claudeProjects/WSL/gsd-dashboard-cast')

from src.video.encoder import FFmpegEncoder
from src.video.quality import get_quality_config

# Configure logging to see output
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

async def test_logging():
    """Test FFmpeg log forwarding by encoding a test pattern."""
    print("=== Testing FFmpeg Log Forwarding ===")

    # Use HLS mode to test with actual FFmpeg execution
    config = get_quality_config('720p')

    async with FFmpegEncoder(config, mode='hls') as encoder:
        print(f"FFmpeg started, stream URL: {encoder.stream_url}")

        # Let it encode for 5 seconds
        print("Encoding for 5 seconds... check logs above for FFmpeg output")
        await asyncio.sleep(5)

        print("Stopping encoder...")

    print("=== Test complete ===")

if __name__ == '__main__':
    asyncio.run(test_logging())
```

Run test:
```bash
cd /root/claudeProjects/WSL/gsd-dashboard-cast
python3 /tmp/test_ffmpeg_logging.py
```

**Expected output in logs:**
- "FFmpeg: Stream mapping" or "FFmpeg: Output #0" (INFO level, codec setup)
- "FFmpeg: frame=..." (DEBUG level, encoding progress)
- No errors or warnings (unless there are actual issues)
- "FFmpeg log forwarding cancelled" (DEBUG level, on cleanup)

**What this verifies:**
1. FFmpeg output is being read from stderr
2. Output is forwarded to application logger
3. Log levels are appropriate (progress at DEBUG, setup at INFO)
4. Task lifecycle works (starts, runs, cancels cleanly)

Clean up test file after verification:
```bash
rm /tmp/test_ffmpeg_logging.py
```
  </action>
  <verify>
1. Verify test script was created successfully:
   ```bash
   test -f /tmp/test_ffmpeg_logging.py && echo "Test script created" || echo "ERROR: Test script not found"
   ```
   Must output "Test script created".

2. Examine test output for FFmpeg log lines:
   ```bash
   python3 /tmp/test_ffmpeg_logging.py 2>&1 | grep "FFmpeg:"
   ```
   Should show multiple lines with "FFmpeg:" prefix.

3. Verify no errors in test execution:
   ```bash
   python3 /tmp/test_ffmpeg_logging.py 2>&1 | grep -i error
   ```
   Should only show "error" in context of log level names, not actual errors.

4. Check that cleanup happens without exceptions:
   ```bash
   python3 /tmp/test_ffmpeg_logging.py 2>&1 | tail -5
   ```
   Should show "Test complete" as final line, no exceptions.
  </verify>
  <done>
- Test script created and verified to exist
- Test script executed successfully
- FFmpeg output visible in application logs
- Log levels appropriate (DEBUG for progress, INFO for setup)
- Cleanup completes without errors
- Gap GAP-09-01 closed: FFmpeg logging now captured
  </done>
</task>

</tasks>

<verification>
## Gap Closure Verification

**GAP-09-01 Resolution:**
- FFmpeg stdout/stderr now read continuously during encoding
- Output forwarded to application logger with appropriate levels
- Background task lifecycle managed (start, run, cancel, cleanup)
- Encoding progress, warnings, and errors now visible in logs

**Testing approach:**
1. Automated: Test script verifies FFmpeg output captured
2. Automated: Syntax and import checks confirm code correctness
3. Automated: Existing tests verify no regressions
4. Human testing (from 09-01): Can now diagnose black screen issues with FFmpeg logs

**Benefits:**
- HLS segment creation visible in logs (addresses HLS-01 verification)
- Buffer window observable via FFmpeg progress (addresses HLS-02 verification)
- Encoding failures diagnosable (error messages captured)
- No more "black box" FFmpeg execution

## Edge Cases Handled

**Pipe buffer deadlock prevention:**
- Background task continuously reads stderr, preventing pipe buffer fill
- If FFmpeg writes large amounts, pipe never blocks

**Cleanup race conditions:**
- Task cancelled BEFORE FFmpeg termination (prevents reading from closed pipe)
- CancelledError caught and suppressed (expected behavior)
- If task completes naturally (EOF), no error raised

**Process startup failure:**
- Log task only started after process successfully created
- If process is None, _log_ffmpeg_output returns immediately

**Log spam prevention:**
- Progress updates (frame=, size=) logged at DEBUG level
- INFO level reserved for meaningful events (codec setup, stream mapping)
- WARNING/ERROR for actual issues
</verification>

<success_criteria>
Gap closure plan complete when:
- [ ] `_log_ffmpeg_output` method added to FFmpegEncoder class
- [ ] Method implements async readline loop with level-based logging
- [ ] `self.log_task` instance variable tracks background task
- [ ] Log task started in __aenter__ after process creation
- [ ] Log task cancelled in __aexit__ BEFORE process termination (correct placement verified)
- [ ] Test script created and verified to exist
- [ ] Test script demonstrates FFmpeg output captured in logs
- [ ] No syntax errors or test regressions
- [ ] GAP-09-01 marked as closed (FFmpeg logging functional)
</success_criteria>

<output>
After completion, create `/root/claudeProjects/WSL/gsd-dashboard-cast/.planning/phases/09-hls-buffering-fix/09-02-SUMMARY.md` following summary.md template.

Include:
- Method implementation details (_log_ffmpeg_output structure)
- Task lifecycle management approach
- Test results showing FFmpeg output in logs
- Example log lines demonstrating different severity levels
- Confirmation that GAP-09-01 is resolved
</output>
