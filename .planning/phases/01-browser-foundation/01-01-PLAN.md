---
phase: 01-browser-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/browser/__init__.py
  - src/browser/manager.py
  - src/browser/auth.py
  - requirements.txt
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Browser instance launches and renders web pages"
    - "Authentication cookies/tokens inject before page load"
    - "Browser cleanup occurs without resource leaks"
  artifacts:
    - path: "src/browser/manager.py"
      provides: "Browser lifecycle management with Playwright"
      min_lines: 40
      exports: ["BrowserManager"]
    - path: "src/browser/auth.py"
      provides: "Authentication injection (cookies/tokens)"
      min_lines: 20
      exports: ["inject_auth"]
    - path: "requirements.txt"
      provides: "Python dependencies"
      contains: "playwright"
  key_links:
    - from: "src/browser/manager.py"
      to: "playwright.chromium.launch()"
      via: "Playwright API call"
      pattern: "chromium\\.launch"
    - from: "src/browser/auth.py"
      to: "page.context.add_cookies()"
      via: "Cookie injection"
      pattern: "add_cookies|add_init_script"
    - from: "src/browser/manager.py"
      to: "browser.close()"
      via: "Cleanup in context manager or explicit close"
      pattern: "close\\(\\)|__exit__"
---

<objective>
Implement Playwright-based browser automation with authentication injection and proper resource management.

Purpose: Establish core capability to launch headless Chrome, inject auth, and render web pages without resource leaks.
Output: Python module for browser lifecycle management with auth support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python project structure with Playwright</name>
  <files>src/browser/__init__.py, src/browser/manager.py, requirements.txt, .gitignore</files>
  <action>
    1. Create src/browser/ directory structure with __init__.py
    2. Add requirements.txt with: playwright>=1.40.0, playwright install chromium (comment for post-install)
    3. Create BrowserManager class in manager.py:
       - Use playwright.chromium.launch() with headless=True
       - Implement as context manager (__enter__/__exit__) for automatic cleanup
       - Store browser and context as instance variables
       - Close browser in __exit__ to prevent resource leaks
       - Include method to get new page: async def get_page(url: str) -> Page
    4. Add .gitignore with: __pycache__/, *.pyc, .pytest_cache/, .venv/

    DO NOT use persistent browser contexts across sessions - research shows this causes memory leaks and stale auth. Create fresh browser per request.
  </action>
  <verify>
    - requirements.txt exists with playwright dependency
    - src/browser/manager.py contains BrowserManager class with __enter__/__exit__
    - Python syntax is valid: python -m py_compile src/browser/manager.py
  </verify>
  <done>BrowserManager class exists with context manager pattern for lifecycle management</done>
</task>

<task type="auto">
  <name>Task 2: Implement authentication injection mechanism</name>
  <files>src/browser/auth.py, src/browser/manager.py</files>
  <action>
    1. Create auth.py with inject_auth function:
       - Accept cookies dict (name->value pairs) and/or localStorage dict
       - Use page.context.add_cookies() for cookies (format: [{"name": k, "value": v, "domain": domain, "path": "/"} for k,v])
       - Use page.add_init_script() for localStorage injection: "Object.assign(window.localStorage, {json.dumps(items)})"
       - Domain extracted from URL: urlparse(url).netloc
    2. Update BrowserManager.get_page() to accept optional auth parameter
    3. Call inject_auth before page.goto() if auth provided

    Support both methods because:
    - Cookies: Standard session auth (Home Assistant, etc.)
    - localStorage: Token-based auth (some dashboards use this)

    DO NOT implement OAuth flows or complex 2FA - out of scope per PROJECT.md. Only cookie/token injection.
  </action>
  <verify>
    - src/browser/auth.py exists with inject_auth function
    - Function accepts cookies and localStorage parameters
    - BrowserManager.get_page() accepts auth parameter
  </verify>
  <done>Auth injection works for both cookies and localStorage before page load</done>
</task>

<task type="auto">
  <name>Task 3: Add resource cleanup and basic test</name>
  <files>src/browser/manager.py, tests/test_browser.py, requirements.txt</files>
  <action>
    1. Add pytest to requirements.txt
    2. Create tests/test_browser.py:
       - Test browser launches and closes cleanly using context manager
       - Test page navigation to simple URL (example.com)
       - Use pytest-asyncio for async tests
       - Mock auth injection test (verify inject_auth is called)
    3. Ensure BrowserManager.__exit__ calls:
       - await self.context.close() if context exists
       - await self.browser.close() if browser exists
       - Handles exceptions gracefully (logs but doesn't raise)

    Resource leak prevention is CRITICAL - Cast sessions may run for hours, browser must not accumulate memory.
  </action>
  <verify>
    - pytest runs successfully: python -m pytest tests/
    - Test verifies browser launches and closes
    - __exit__ method includes close() calls with exception handling
  </verify>
  <done>Tests pass, resource cleanup verified in context manager exit</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/ passes
- [ ] requirements.txt contains playwright and pytest
- [ ] BrowserManager uses context manager pattern
- [ ] inject_auth supports cookies and localStorage
- [ ] No obvious resource leaks (browser.close() in __exit__)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- BrowserManager can launch browser, inject auth, navigate to URL, and clean up
- Tests demonstrate lifecycle works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-browser-foundation/01-01-SUMMARY.md`
</output>
