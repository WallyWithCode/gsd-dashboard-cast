---
phase: 07-ffmpeg-dual-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/video/encoder.py, src/video/quality.py]
autonomous: true

must_haves:
  truths:
    - "HLS mode produces .m3u8 playlist with .ts segment files"
    - "fMP4 mode produces fragmented .mp4 stream file"
    - "Video uses H.264 High Profile Level 4.1 for Cast compatibility"
    - "Both modes work with existing StreamingServer"
  artifacts:
    - path: "src/video/encoder.py"
      provides: "Dual-mode FFmpeg encoding (HLS and fMP4)"
      contains: "mode.*hls.*fmp4"
  key_links:
    - from: "FFmpegEncoder.__init__"
      to: "build_ffmpeg_args"
      via: "mode parameter"
      pattern: "mode.*Literal"
---

<objective>
Add dual-mode output support to FFmpegEncoder: HLS (buffered) for dashboard reliability and fMP4 (low-latency) for camera feeds.

Purpose: Enable Cast device playback with appropriate streaming format based on use case. HLS provides reliable buffered playback; fMP4 provides lower latency for real-time content.

Output: FFmpegEncoder produces either HLS (.m3u8 + .ts) or fMP4 (.mp4) based on mode parameter, with Cast-compatible H.264 encoding.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-http-streaming-server/06-02-SUMMARY.md

@src/video/encoder.py
@src/video/quality.py
@src/video/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode parameter and dual-mode FFmpeg output</name>
  <files>src/video/encoder.py</files>
  <action>
Update FFmpegEncoder to support mode-based output:

1. Add `mode: Literal['hls', 'fmp4'] = 'hls'` parameter to __init__

2. Modify build_ffmpeg_args() to generate different output based on mode:

**HLS mode (existing, with improvements):**
```python
args.extend([
    '-f', 'hls',
    '-hls_time', '2',
    '-hls_list_size', '3',
    '-hls_flags', 'delete_segments',
    output_file,  # .m3u8
])
```

**fMP4 mode (new):**
```python
args.extend([
    '-f', 'mp4',
    '-movflags', 'frag_keyframe+empty_moov+default_base_moof',
    output_file,  # .mp4
])
```

The `-movflags frag_keyframe+empty_moov+default_base_moof` flags enable:
- `frag_keyframe`: Fragment at keyframes for seekability
- `empty_moov`: Start with empty moov (enables streaming before file complete)
- `default_base_moof`: Use default base for moof (Cast compatibility)

3. Update __aenter__ to generate correct file extension:
- HLS: `stream_{id}.m3u8`
- fMP4: `stream_{id}.mp4`

4. Update __aexit__ cleanup to handle .mp4 files (no .ts segments for fMP4)

5. Add H.264 profile/level for Cast compatibility to BOTH modes:
```python
'-profile:v', 'high',
'-level:v', '4.1',
```

This ensures universal Chromecast compatibility (all Cast devices support H.264 High 4.1).
  </action>
  <verify>
- Python syntax check: `python -m py_compile src/video/encoder.py`
- Import check: `python -c "from src.video.encoder import FFmpegEncoder; print('OK')"`
  </verify>
  <done>
- FFmpegEncoder accepts mode='hls' or mode='fmp4'
- HLS mode produces .m3u8 playlist with .ts segments
- fMP4 mode produces fragmented .mp4 file
- Both modes use H.264 High Profile Level 4.1
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AAC audio encoding for Cast playback</name>
  <files>src/video/encoder.py</files>
  <action>
Current encoder uses x11grab which captures video only. Cast devices expect audio even if silent.

Add silent audio track generation to build_ffmpeg_args():

```python
# Add silent audio source (required for Cast playback)
# Use anullsrc filter for silent audio
args.extend([
    '-f', 'lavfi',
    '-i', 'anullsrc=r=44100:cl=stereo',
])

# After video codec settings, add audio codec:
args.extend([
    '-c:a', 'aac',
    '-b:a', '128k',
    '-ar', '44100',
    '-ac', '2',
    '-shortest',  # End when shortest input ends (video)
])
```

The `-shortest` flag ensures encoding stops when video ends, not waiting for infinite audio source.

Input indices become:
- Input 0: x11grab (video)
- Input 1: anullsrc (silent audio)

Map both inputs explicitly:
```python
'-map', '0:v',  # Video from x11grab
'-map', '1:a',  # Audio from anullsrc
```

This provides Cast-compatible AAC audio (even if silent) which many Cast apps require.
  </action>
  <verify>
- Python syntax check: `python -m py_compile src/video/encoder.py`
- Check AAC args present: `grep -n "aac" src/video/encoder.py`
  </verify>
  <done>
- FFmpeg args include AAC audio encoding
- Silent audio track generated for Cast compatibility
- Both HLS and fMP4 modes include audio
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile src/video/encoder.py` passes
- [ ] FFmpegEncoder accepts mode parameter
- [ ] build_ffmpeg_args() generates different args for 'hls' vs 'fmp4'
- [ ] H.264 profile/level args present: `-profile:v high -level:v 4.1`
- [ ] AAC audio args present: `-c:a aac`
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- FFmpegEncoder supports dual-mode output (HLS and fMP4)
- Cast-compatible encoding settings (H.264 High 4.1 + AAC audio)
</success_criteria>

<output>
After completion, create `.planning/phases/07-ffmpeg-dual-mode/07-01-SUMMARY.md`
</output>
