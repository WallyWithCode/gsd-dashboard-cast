---
phase: 07-ffmpeg-dual-mode
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified: [src/api/models.py, src/api/routes.py, src/api/state.py, src/video/stream.py]
autonomous: true

must_haves:
  truths:
    - "Webhook /start accepts mode parameter (hls or fmp4)"
    - "Mode parameter flows from API to FFmpegEncoder"
    - "Default mode is 'hls' when not specified"
  artifacts:
    - path: "src/api/models.py"
      provides: "StartRequest with mode field"
      contains: "mode.*Literal"
    - path: "src/video/stream.py"
      provides: "StreamManager with mode parameter"
      contains: "mode.*hls.*fmp4"
  key_links:
    - from: "StartRequest.mode"
      to: "StreamTracker.start_stream"
      via: "routes.py passes mode"
      pattern: "request\\.mode"
    - from: "StreamTracker._run_stream"
      to: "StreamManager"
      via: "mode parameter"
      pattern: "mode=mode"
    - from: "StreamManager.start_stream"
      to: "FFmpegEncoder"
      via: "mode parameter"
      pattern: "FFmpegEncoder.*mode"
---

<objective>
Wire the mode parameter from webhook API through to FFmpegEncoder, enabling per-request streaming mode selection.

Purpose: Allow webhook callers to choose HLS (buffered) for dashboards or fMP4 (low-latency) for camera feeds based on their use case.

Output: /start endpoint accepts `mode` parameter that flows through StreamTracker → StreamManager → FFmpegEncoder.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-ffmpeg-dual-mode/07-01-SUMMARY.md

@src/api/models.py
@src/api/routes.py
@src/api/state.py
@src/video/stream.py
@src/video/encoder.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mode parameter to API models and routes</name>
  <files>src/api/models.py, src/api/routes.py</files>
  <action>
**1. Update StartRequest in models.py:**

Add mode field with Literal type:

```python
from typing import Optional, Literal

class StartRequest(BaseModel):
    """Request model for starting a cast stream."""
    url: HttpUrl
    quality: str = "1080p"
    duration: Optional[int] = None
    mode: Literal['hls', 'fmp4'] = 'hls'  # Streaming mode: HLS (buffered) or fMP4 (low-latency)
```

**2. Update routes.py start_cast endpoint:**

Pass mode to stream_tracker.start_stream():

```python
await app.state.stream_tracker.start_stream(
    session_id,
    str(request.url),
    request.quality,
    request.duration,
    request.mode  # Add mode parameter
)
```

Update logger.info to include mode:
```python
logger.info("webhook_start", url=str(request.url), quality=request.quality, duration=request.duration, mode=request.mode)
```
  </action>
  <verify>
- Python syntax check: `python -m py_compile src/api/models.py src/api/routes.py`
- Verify mode field: `grep -n "mode" src/api/models.py`
  </verify>
  <done>
- StartRequest includes mode field with Literal['hls', 'fmp4']
- Default mode is 'hls'
- routes.py passes mode to stream_tracker
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire mode through StreamTracker and StreamManager to encoder</name>
  <files>src/api/state.py, src/video/stream.py</files>
  <action>
**1. Update StreamTracker in state.py:**

Add mode parameter to start_stream and _run_stream:

```python
async def start_stream(self, session_id: str, url: str, quality: str, duration: Optional[int], mode: str = 'hls') -> str:
    """Launch stream as background task.

    Args:
        session_id: Unique identifier for this stream session
        url: Target URL to cast
        quality: Quality preset ('1080p', '720p', 'low-latency')
        duration: Optional duration in seconds (None = indefinite)
        mode: Streaming mode ('hls' or 'fmp4')
    """
    task = asyncio.create_task(self._run_stream(session_id, url, quality, duration, mode))
    ...
```

Update _run_stream to pass mode to StreamManager:
```python
async def _run_stream(self, session_id: str, url: str, quality: str, duration: Optional[int], mode: str = 'hls'):
    ...
    stream_manager = StreamManager(
        url=url,
        cast_device_name=cast_device_name,
        quality_preset=quality,
        duration=duration,
        mode=mode  # Add mode parameter
    )
```

**2. Update StreamManager in stream.py:**

Add mode parameter to __init__:
```python
def __init__(
    self,
    url: str,
    cast_device_name: str,
    quality_preset: str = "720p",
    duration: Optional[int] = None,
    auth_config: Optional[dict] = None,
    mode: str = 'hls'  # Add mode parameter
):
    ...
    self.mode = mode
```

Pass mode to FFmpegEncoder in start_stream:
```python
async with FFmpegEncoder(quality, display=display, mode=self.mode) as stream_url:
```

Update logging to include mode:
```python
logger.info(
    f"StreamManager initialized: url={url}, device={cast_device_name}, "
    f"quality={quality_preset}, duration={duration}, mode={mode}"
)
```
  </action>
  <verify>
- Python syntax check: `python -m py_compile src/api/state.py src/video/stream.py`
- Verify mode flows through: `grep -n "mode" src/api/state.py src/video/stream.py`
  </verify>
  <done>
- StreamTracker.start_stream accepts mode parameter
- StreamTracker._run_stream passes mode to StreamManager
- StreamManager passes mode to FFmpegEncoder
- Mode parameter flows from API to encoder
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m py_compile src/api/models.py src/api/routes.py src/api/state.py src/video/stream.py` passes
- [ ] Mode field exists in StartRequest with default 'hls'
- [ ] routes.py passes request.mode to stream_tracker
- [ ] StreamTracker passes mode to StreamManager
- [ ] StreamManager passes mode to FFmpegEncoder
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Mode parameter flows from /start webhook to FFmpegEncoder
- Default mode is 'hls' when not specified
</success_criteria>

<output>
After completion, create `.planning/phases/07-ffmpeg-dual-mode/07-02-SUMMARY.md`
</output>
